import YError from 'yerror';
import { autoService, options } from 'knifecycle';

const noop = () => {};

export default options({
  singleton: true
}, autoService(initLock), true);

async function initLock({
  LOCKS_MAP = new Map(),
  LOCK_TIMEOUT = Infinity,
  delay,
  log = noop
}) {
  log('debug', '🔒 - Lock service initialized.');
  return {
    take,
    release
  };

  async function take(key) {
    const previousLocks = LOCKS_MAP.get(key) || [];
    let locksLength = previousLocks.length;
    log('debug', `🔐 - Taking the lock on ${key} (queue length was ${locksLength})`);

    let _resolve;

    const releasePromise = new Promise((resolve, reject) => {
      _resolve = resolve;

      if (LOCK_TIMEOUT !== Infinity) {
        delay.create(LOCK_TIMEOUT).then(() => reject(new YError('E_LOCK_TIMEOUT')));
      }
    });
    const newLock = {
      releasePromise,
      release: _resolve
    };
    previousLocks.push(newLock);
    locksLength++;

    if (locksLength > 1) {
      await previousLocks[locksLength - 1].releasePromise;
    } else {
      LOCKS_MAP.set(key, previousLocks);
    }
  }

  async function release(key) {
    const previousLocks = LOCKS_MAP.get(key) || [];
    const locksLength = previousLocks.length;
    log('debug', `🔓 - Releasing the lock on ${key} (queue length was ${locksLength})`);
    previousLocks.pop().release();
  }
}
//# sourceMappingURL=lock.mjs.map