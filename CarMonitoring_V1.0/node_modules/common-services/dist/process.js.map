{"version":3,"sources":["../src/process.ts"],"names":["DEFAULT_NODE_ENVS","DEFAULT_SIGNALS","noop","singleton","initProcess","NODE_ENV","PROCESS_NAME","SIGNALS","NODE_ENVS","log","exit","$instance","$fatalError","shuttingDown","signalsListeners","map","signal","terminate","bind","includes","YError","global","process","title","forEach","signalListener","on","promise","catch","err","stack","catchUncaughtException","shutdown","code","destroy","dispose","removeListener","service"],"mappings":"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","sourcesContent":["import YError from 'yerror';\nimport { autoProvider, options } from 'knifecycle';\nimport type { Knifecycle, FatalErrorProvider } from 'knifecycle';\nimport type { LogService } from './log';\n\nconst DEFAULT_NODE_ENVS = ['development', 'test', 'production'];\nconst DEFAULT_SIGNALS: NodeJS.Signals[] = ['SIGTERM', 'SIGINT'];\n\nfunction noop() {}\n\nexport type ProcessServiceConfig = {\n  NODE_ENV?: string;\n  PROCESS_NAME?: string;\n  SIGNALS?: NodeJS.Signals[];\n  NODE_ENVS?: string[];\n};\nexport type ProcessServiceDependencies = ProcessServiceConfig & {\n  NODE_ENV: string;\n  exit: Function;\n  $instance: Knifecycle;\n  $fatalError: FatalErrorProvider;\n  log?: LogService;\n};\n\n/* Architecture Note #1.5: Process\nThe `process` service takes care of the process status.\n\nIt returns nothing and should be injected only for its\n side effects.\n*/\n\nexport default options({ singleton: true }, autoProvider(initProcess), true);\n\n/**\n * Instantiate the process service\n * @name initProcess\n * @function\n * @param  {Object}   services\n * The services to inject\n * @return {Promise<Object>}\n * A promise of the process object\n */\nasync function initProcess({\n  NODE_ENV,\n  PROCESS_NAME = '',\n  SIGNALS = DEFAULT_SIGNALS,\n  NODE_ENVS = DEFAULT_NODE_ENVS,\n  log = noop,\n  exit,\n  $instance,\n  $fatalError,\n}: ProcessServiceDependencies): Promise<{\n  service: NodeJS.Process;\n  dispose: () => Promise<void>;\n}> {\n  let shuttingDown = null;\n  let signalsListeners = SIGNALS.map<[NodeJS.Signals, NodeJS.SignalsListener]>(\n    (signal) => [signal, terminate.bind(null, signal)],\n  );\n\n  /* Architecture Note #1.5.1: Node environment filtering\n\n  It also forces NODE_ENV to be set to avoid unintentionnal\n   development version shipping to production. You can specify\n   your own list of valid environments by injecting the\n   `SIGNALS` optional dependency.\n  */\n  if (!NODE_ENVS.includes(NODE_ENV)) {\n    throw new YError('E_NODE_ENV', NODE_ENV);\n  }\n\n  log('warning', `🔂 - Running in \"${NODE_ENV}\" environment.`);\n\n  global.process.title =\n    (PROCESS_NAME || global.process.title) + ' - ' + NODE_ENV;\n\n  /* Architecture Note #1.5.2: Signals handling\n\n  It also handle SIGINT and SIGTERM signals to allow to\n   gracefully shutdown the running process. The signals\n   to handle can be customized by injecting the `SIGNALS`\n   optional dependencies.\n  */\n  signalsListeners.forEach(([signal, signalListener]) => {\n    global.process.on(signal, signalListener);\n  });\n\n  /* Architecture Note #1.5.3: Handling services fatal errors\n\n  If an error occurs it attempts to gracefully exit\n  to give it a chance to finish properly.\n  */\n  $fatalError.promise.catch((err) => {\n    log('error', '💀 - Fatal error');\n    log('stack', err.stack || err);\n    terminate('FATAL');\n  });\n\n  /* Architecture Note #1.5.4: Uncaught exceptions\n\n  If an uncaught exeption occurs it also attempts to\n   gracefully exit since a process should never be kept\n   alive when an uncaught exception is raised.\n  */\n  global.process.on('uncaughtException', catchUncaughtException);\n\n  function catchUncaughtException(err) {\n    log('error', '💀 - Uncaught Exception');\n    log('stack', err.stack || err);\n    terminate('ERR');\n  }\n\n  function terminate(signal) {\n    if (shuttingDown) {\n      log('warning', `🚦 - ${signal} received again, shutdown now.`);\n      exit(1);\n    } else {\n      log(\n        'warning',\n        `🚦 - ${signal} received. Send it again to kill me instantly.`,\n      );\n      shutdown(['ERR', 'FATAL'].includes(signal) ? 1 : 0);\n    }\n  }\n\n  async function shutdown(code) {\n    shuttingDown = true;\n    log('warning', 'Shutting down now 🙏...');\n    await $instance.destroy();\n\n    try {\n      log('warning', '😎 - Gracefull shutdown sucessfully done !');\n      exit(code || 0);\n    } catch (err) {\n      log('error', '🤔 - Could not gracefully shutdown.');\n      log('stack', err.stack || err);\n      exit(1);\n    }\n  }\n\n  async function dispose() {\n    global.process.removeListener('uncaughtException', catchUncaughtException);\n    signalsListeners.forEach(([signal, signalListener]) => {\n      global.process.removeListener(signal, signalListener);\n    });\n  }\n\n  log('debug', '📇 - Process service initialized.');\n  return {\n    service: global.process,\n    dispose,\n  };\n}\n"],"file":"process.js"}