{"ast":null,"code":"/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Decodes an encoded path string into a sequence of LatLngs.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n *  #### Example\n *\n * ```js\n * import { decode } from \"@googlemaps/polyline-codec\";\n *\n * const encoded = \"_p~iF~ps|U_ulLnnqC_mqNvxq`@\";\n * console.log(decode(encoded, 5));\n * // [\n * //   [38.5, -120.2],\n * //   [40.7, -120.95],\n * //   [43.252, -126.453],\n * // ]\n * ```\n */\nvar decode = function (encodedPath, precision) {\n  if (precision === void 0) {\n    precision = 5;\n  }\n\n  var factor = Math.pow(10, precision);\n  var len = encodedPath.length; // For speed we preallocate to an upper bound on the final length, then\n  // truncate the array before returning.\n\n  var path = new Array(Math.floor(encodedPath.length / 2));\n  var index = 0;\n  var lat = 0;\n  var lng = 0;\n  var pointIndex = 0; // This code has been profiled and optimized, so don't modify it without\n  // measuring its performance.\n\n  for (; index < len; ++pointIndex) {\n    // Fully unrolling the following loops speeds things up about 5%.\n    var result = 1;\n    var shift = 0;\n    var b = void 0;\n\n    do {\n      // Invariant: \"result\" is current partial result plus (1 << shift).\n      // The following line effectively clears this bit by decrementing \"b\".\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f); // See note above.\n\n\n    lat += result & 1 ? ~(result >> 1) : result >> 1;\n    result = 1;\n    shift = 0;\n\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n\n    lng += result & 1 ? ~(result >> 1) : result >> 1;\n    path[pointIndex] = [lat / factor, lng / factor];\n  } // truncate array\n\n\n  path.length = pointIndex;\n  return path;\n};\n/**\n * Polyline encodes an array of objects having lat and lng properties.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * #### Example\n *\n * ```js\n * import { encode } from \"@googlemaps/polyline-codec\";\n *\n * const path = [\n *   [38.5, -120.2],\n *   [40.7, -120.95],\n *   [43.252, -126.453],\n * ];\n * console.log(encode(path, 5));\n * // \"_p~iF~ps|U_ulLnnqC_mqNvxq`@\"\n * ```\n */\n\n\nvar encode = function (path, precision) {\n  if (precision === void 0) {\n    precision = 5;\n  }\n\n  var factor = Math.pow(10, precision);\n\n  var transform = function latLngToFixed(latLng) {\n    if (!Array.isArray(latLng)) {\n      latLng = [latLng.lat, latLng.lng];\n    }\n\n    return [round(latLng[0] * factor), round(latLng[1] * factor)];\n  };\n\n  return polylineEncodeLine(path, transform);\n};\n/**\n * Encodes a generic polyline; optionally performing a transform on each point\n * before encoding it.\n *\n * @ignore\n */\n\n\nvar polylineEncodeLine = function (array, transform) {\n  var v = [];\n  var start = [0, 0];\n  var end;\n\n  for (var i = 0, I = array.length; i < I; ++i) {\n    // In order to prevent drift (from quantizing deltas), we explicitly convert\n    // coordinates to fixed-precision to obtain integer deltas.\n    end = transform(array[i]); // Push the next edge\n\n    polylineEncodeSigned(round(end[0]) - round(start[0]), v); // lat\n\n    polylineEncodeSigned(round(end[1]) - round(start[1]), v); // lng\n\n    start = end;\n  }\n\n  return v.join(\"\");\n};\n/**\n * Encodes the given value in our compact polyline format, appending the\n * encoded value to the given array of strings.\n *\n * @ignore\n */\n\n\nvar polylineEncodeSigned = function (value, array) {\n  return polylineEncodeUnsigned(value < 0 ? ~(value << 1) : value << 1, array);\n};\n/**\n * Helper function for encodeSigned.\n *\n * @ignore\n */\n\n\nvar polylineEncodeUnsigned = function (value, array) {\n  while (value >= 0x20) {\n    array.push(String.fromCharCode((0x20 | value & 0x1f) + 63));\n    value >>= 5;\n  }\n\n  array.push(String.fromCharCode(value + 63));\n  return array;\n};\n/**\n * @ignore\n */\n\n\nvar round = function (v) {\n  return Math.floor(Math.abs(v) + 0.5) * (v >= 0 ? 1 : -1);\n};\n\nexport { decode, encode, polylineEncodeLine };","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes an encoded path string into a sequence of LatLngs.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n *  #### Example\n *\n * ```js\n * import { decode } from \"@googlemaps/polyline-codec\";\n *\n * const encoded = \"_p~iF~ps|U_ulLnnqC_mqNvxq`@\";\n * console.log(decode(encoded, 5));\n * // [\n * //   [38.5, -120.2],\n * //   [40.7, -120.95],\n * //   [43.252, -126.453],\n * // ]\n * ```\n */\nvar decode = function (encodedPath, precision) {\n    if (precision === void 0) { precision = 5; }\n    var factor = Math.pow(10, precision);\n    var len = encodedPath.length;\n    // For speed we preallocate to an upper bound on the final length, then\n    // truncate the array before returning.\n    var path = new Array(Math.floor(encodedPath.length / 2));\n    var index = 0;\n    var lat = 0;\n    var lng = 0;\n    var pointIndex = 0;\n    // This code has been profiled and optimized, so don't modify it without\n    // measuring its performance.\n    for (; index < len; ++pointIndex) {\n        // Fully unrolling the following loops speeds things up about 5%.\n        var result = 1;\n        var shift = 0;\n        var b = void 0;\n        do {\n            // Invariant: \"result\" is current partial result plus (1 << shift).\n            // The following line effectively clears this bit by decrementing \"b\".\n            b = encodedPath.charCodeAt(index++) - 63 - 1;\n            result += b << shift;\n            shift += 5;\n        } while (b >= 0x1f); // See note above.\n        lat += result & 1 ? ~(result >> 1) : result >> 1;\n        result = 1;\n        shift = 0;\n        do {\n            b = encodedPath.charCodeAt(index++) - 63 - 1;\n            result += b << shift;\n            shift += 5;\n        } while (b >= 0x1f);\n        lng += result & 1 ? ~(result >> 1) : result >> 1;\n        path[pointIndex] = [lat / factor, lng / factor];\n    }\n    // truncate array\n    path.length = pointIndex;\n    return path;\n};\n/**\n * Polyline encodes an array of objects having lat and lng properties.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * #### Example\n *\n * ```js\n * import { encode } from \"@googlemaps/polyline-codec\";\n *\n * const path = [\n *   [38.5, -120.2],\n *   [40.7, -120.95],\n *   [43.252, -126.453],\n * ];\n * console.log(encode(path, 5));\n * // \"_p~iF~ps|U_ulLnnqC_mqNvxq`@\"\n * ```\n */\nvar encode = function (path, precision) {\n    if (precision === void 0) { precision = 5; }\n    var factor = Math.pow(10, precision);\n    var transform = function latLngToFixed(latLng) {\n        if (!Array.isArray(latLng)) {\n            latLng = [latLng.lat, latLng.lng];\n        }\n        return [round(latLng[0] * factor), round(latLng[1] * factor)];\n    };\n    return polylineEncodeLine(path, transform);\n};\n/**\n * Encodes a generic polyline; optionally performing a transform on each point\n * before encoding it.\n *\n * @ignore\n */\nvar polylineEncodeLine = function (array, transform) {\n    var v = [];\n    var start = [0, 0];\n    var end;\n    for (var i = 0, I = array.length; i < I; ++i) {\n        // In order to prevent drift (from quantizing deltas), we explicitly convert\n        // coordinates to fixed-precision to obtain integer deltas.\n        end = transform(array[i]);\n        // Push the next edge\n        polylineEncodeSigned(round(end[0]) - round(start[0]), v); // lat\n        polylineEncodeSigned(round(end[1]) - round(start[1]), v); // lng\n        start = end;\n    }\n    return v.join(\"\");\n};\n/**\n * Encodes the given value in our compact polyline format, appending the\n * encoded value to the given array of strings.\n *\n * @ignore\n */\nvar polylineEncodeSigned = function (value, array) {\n    return polylineEncodeUnsigned(value < 0 ? ~(value << 1) : value << 1, array);\n};\n/**\n * Helper function for encodeSigned.\n *\n * @ignore\n */\nvar polylineEncodeUnsigned = function (value, array) {\n    while (value >= 0x20) {\n        array.push(String.fromCharCode((0x20 | (value & 0x1f)) + 63));\n        value >>= 5;\n    }\n    array.push(String.fromCharCode(value + 63));\n    return array;\n};\n/**\n * @ignore\n */\nvar round = function (v) {\n    return Math.floor(Math.abs(v) + 0.5) * (v >= 0 ? 1 : -1);\n};\n\nexport { decode, encode, polylineEncodeLine };\n//# sourceMappingURL=index.esm.js.map\n"]},"metadata":{},"sourceType":"module"}