{"version":3,"sources":["../src/build.js"],"names":["name","type","inject","initInitializerBuilder","$autoload","buildInitializer","dependencies","dependencyTrees","Promise","all","map","dependency","buildDependencyTree","dependenciesHash","buildDependenciesHash","filter","identity","batches","__name","__childNodes","pop","batch","index","__initializer","SPECIAL_PROPS","TYPE","JSON","stringify","VALUE","__initializerName","__path","join","__inject","parseDependencyDeclaration","serviceName","mappedName","__type","dependencyDeclaration","optional","path","initializer","node","INJECT","upperCaseFirst","length","childNodes","childDependencyDeclaration","err","hash","reduce","tree","buildHashFromNode","nodeIsALeaf","forEach","childNode","a","str","toUpperCase","slice"],"mappings":"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","sourcesContent":["import { SPECIAL_PROPS, parseDependencyDeclaration, initializer } from './util';\nimport { buildInitializationSequence } from './sequence';\n\n/* Architecture Note #2: Build\n\nUsing Knifecycle only makes sense for\n monoliths. For some targets like\n serverless functions, a better\n approach is to simply build a raw\n initialization function.\n\nFor the build to work, we need:\n- a hash of various constants that may be\n used.\n- an autoloader that resolves dependencies\n names to its actual initializer\n- the dependencies list you want to\n initialize\n*/\n\nexport default initializer(\n  {\n    name: 'buildInitializer',\n    type: 'service',\n    inject: ['$autoload'],\n  },\n  initInitializerBuilder,\n);\n\n/**\n * Instantiate the initializer builder service\n * @param  {Object}   services\n * The services to inject\n * @param  {Object}   services.$autoload\n * The dependencies autoloader\n * @return {Promise<Function>}\n * A promise of the buildInitializer function\n * @example\n * import initInitializerBuilder from 'knifecycle/dist/build';\n *\n * const buildInitializer = await initInitializerBuilder({\n *   $autoload: async () => {},\n * });\n */\nasync function initInitializerBuilder({ $autoload }) {\n  return buildInitializer;\n\n  /**\n   * Create a JavaScript module that initialize\n   * a set of dependencies with hardcoded\n   * import/awaits.\n   * @param  {String[]} dependencies\n   * The main dependencies\n   * @return {Promise<String>}\n   * The JavaScript module content\n   * @example\n   * import initInitializerBuilder from 'knifecycle/dist/build';\n   *\n   * const buildInitializer = await initInitializerBuilder({\n   *   $autoload: async () => {},\n   * });\n   *\n   * const content = await buildInitializer(['entryPoint']);\n   */\n  async function buildInitializer(dependencies) {\n    const dependencyTrees = await Promise.all(\n      dependencies.map((dependency) =>\n        buildDependencyTree({ $autoload }, dependency),\n      ),\n    );\n    const dependenciesHash = buildDependenciesHash(\n      dependencyTrees.filter(identity),\n    );\n    const batches = buildInitializationSequence({\n      __name: 'main',\n      __childNodes: dependencyTrees.filter(identity),\n    });\n    batches.pop();\n\n    return `${batches\n      .map(\n        (batch, index) => `\n// Definition batch #${index}${batch\n          .map((name) => {\n            if (\n              'constant' ===\n              dependenciesHash[name].__initializer[SPECIAL_PROPS.TYPE]\n            ) {\n              return `\nconst ${name} = ${JSON.stringify(\n                dependenciesHash[name].__initializer[SPECIAL_PROPS.VALUE],\n                null,\n                2,\n              )};`;\n            }\n\n            return `\nimport ${dependenciesHash[name].__initializerName} from '${dependenciesHash[name].__path}';`;\n          })\n          .join('')}`,\n      )\n      .join('\\n')}\n\nexport async function initialize(services = {}) {${batches\n      .map(\n        (batch, index) => `\n  // Initialization batch #${index}\n  const batch${index} = {${batch\n          .map((name) => {\n            if (\n              'constant' ===\n              dependenciesHash[name].__initializer[SPECIAL_PROPS.TYPE]\n            ) {\n              return `\n    ${name}: Promise.resolve(${name}),`;\n            }\n            return `\n    ${name}: ${dependenciesHash[name].__initializerName}({${\n              dependenciesHash[name].__inject\n                ? `${dependenciesHash[name].__inject\n                    .map(parseDependencyDeclaration)\n                    .map(\n                      ({ serviceName, mappedName }) =>\n                        `\n      ${serviceName}: services['${mappedName}'],`,\n                    )\n                    .join('')}`\n                : ''\n            }\n    })${\n      'provider' === dependenciesHash[name].__type\n        ? '.then(provider => provider.service)'\n        : ''\n    },`;\n          })\n          .join('')}\n  };\n\n  await Promise.all(\n    Object.keys(batch${index})\n    .map(key => batch${index}[key])\n  );\n${batch\n  .map((name) => {\n    return `\n  services['${name}'] = await batch${index}['${name}'];`;\n  })\n  .join('')}\n`,\n      )\n      .join('')}\n  return {${dependencies\n    .map(parseDependencyDeclaration)\n    .map(\n      ({ serviceName, mappedName }) =>\n        `\n    ${serviceName}: services['${mappedName}'],`,\n    )\n    .join('')}\n  };\n}\n`;\n  }\n}\n\nasync function buildDependencyTree({ $autoload }, dependencyDeclaration) {\n  const { mappedName, optional } = parseDependencyDeclaration(\n    dependencyDeclaration,\n  );\n\n  try {\n    const { path, initializer } = await $autoload(mappedName);\n    const node = {\n      __name: mappedName,\n      __initializer: initializer,\n      __inject:\n        initializer && initializer[SPECIAL_PROPS.INJECT]\n          ? initializer[SPECIAL_PROPS.INJECT]\n          : [],\n      __type:\n        initializer && initializer[SPECIAL_PROPS.TYPE]\n          ? initializer[SPECIAL_PROPS.TYPE]\n          : 'provider',\n      __initializerName: 'init' + upperCaseFirst(mappedName),\n      __path: path,\n      __childNodes: [],\n    };\n\n    if (\n      initializer[SPECIAL_PROPS.INJECT] &&\n      initializer[SPECIAL_PROPS.INJECT].length\n    ) {\n      const childNodes = await Promise.all(\n        initializer[SPECIAL_PROPS.INJECT].map((childDependencyDeclaration) =>\n          buildDependencyTree({ $autoload }, childDependencyDeclaration),\n        ),\n      );\n      node.__childNodes = childNodes.filter(identity);\n      return node;\n    } else {\n      return node;\n    }\n  } catch (err) {\n    if (optional) {\n      return null;\n    }\n    throw err;\n  }\n}\n\nfunction buildDependenciesHash(dependencyTrees, hash = {}) {\n  return dependencyTrees.reduce(\n    (hash, tree) => buildHashFromNode(tree, hash),\n    hash,\n  );\n}\n\nfunction buildHashFromNode(node, hash = {}) {\n  const nodeIsALeaf = !(node.__childNodes && node.__childNodes.length);\n\n  hash[node.__name] = node;\n\n  if (nodeIsALeaf) {\n    return hash;\n  }\n\n  node.__childNodes.forEach((childNode) => {\n    hash = buildHashFromNode(childNode, hash);\n  });\n\n  return hash;\n}\n\nfunction identity(a) {\n  return a;\n}\n\nfunction upperCaseFirst(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n"],"file":"build.js"}