import YError from 'yerror';
import initDebug from 'debug';
const debug = initDebug('knifecycle');
export const SPECIAL_PROPS_PREFIX = '$';
export const SPECIAL_PROPS = {
  INJECT: `${SPECIAL_PROPS_PREFIX}inject`,
  OPTIONS: `${SPECIAL_PROPS_PREFIX}options`,
  NAME: `${SPECIAL_PROPS_PREFIX}name`,
  TYPE: `${SPECIAL_PROPS_PREFIX}type`,
  EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,
  VALUE: `${SPECIAL_PROPS_PREFIX}value`
};
export const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map(key => SPECIAL_PROPS[key]);
export const DECLARATION_SEPARATOR = '>';
export const OPTIONAL_FLAG = '?';
export const ALLOWED_INITIALIZER_TYPES = ['provider', 'service', 'constant'];
const E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';
const E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';
export function reuseSpecialProps(from, to, amend = {}) {
  return [...new Set(Object.keys(from).concat(Object.keys(amend)))].filter(prop => prop.startsWith(SPECIAL_PROPS_PREFIX)).reduce((fn, prop) => {
    const value = 'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];

    if (value instanceof Array) {
      fn[prop] = value.concat();
    } else if (value instanceof Object) {
      fn[prop] = Object.assign({}, value);
    } else {
      fn[prop] = value;
    }

    return fn;
  }, to.bind());
}
export function wrapInitializer(wrapper, baseInitializer) {
  return reuseSpecialProps(baseInitializer, async services => {
    const baseInstance = await baseInitializer(services);
    return wrapper(services, baseInstance);
  });
}
export function inject(dependencies, initializer) {
  if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {
    throw new YError(E_BAD_INJECT_IN_CONSTANT, initializer[SPECIAL_PROPS.NAME], dependencies);
  }

  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.INJECT]: dependencies
  });
  debug('Wrapped an initializer with dependencies:', dependencies);
  return uniqueInitializer;
}
export function useInject(from, to) {
  return inject(from[SPECIAL_PROPS.INJECT] || [], to);
}
export function mergeInject(from, to) {
  return alsoInject(from[SPECIAL_PROPS.INJECT] || [], to);
}
export function autoInject(initializer) {
  const source = initializer.toString();
  const dependencies = parseInjections(source);
  return inject(dependencies, initializer);
}
export function parseInjections(source, {
  allowEmpty = false
} = {
  allowEmpty: false
}) {
  const matches = source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\{\s*([^{}]+)(\s*\.\.\.[^{}]+|)\s*\}/);

  if (!matches) {
    if (!source.match(/^\s*async/)) {
      throw new YError('E_NON_ASYNC_INITIALIZER', source);
    }

    if (allowEmpty && source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\)/)) {
      return [];
    }

    throw new YError('E_AUTO_INJECTION_FAILURE', source);
  }

  return matches[1].trim().replace(/,$/, '').split(/\s*,\s*/).map(s => s.trim()).filter(s => !s.startsWith('...')).map(injection => (injection.includes('=') ? '?' : '') + injection.split(/\s*=\s*/).shift().split(/\s*:\s*/).shift()).filter(injection => !/[)(\][]/.test(injection));
}
export function alsoInject(dependencies, initializer) {
  const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(parseDependencyDeclaration);
  const addedDependencies = dependencies.map(parseDependencyDeclaration);
  const dedupedDependencies = currentDependencies.filter(({
    serviceName
  }) => {
    const declarationIsOverridden = addedDependencies.some(({
      serviceName: addedServiceName
    }) => {
      return addedServiceName === serviceName;
    });
    return !declarationIsOverridden;
  }).concat(addedDependencies.map(({
    serviceName,
    mappedName,
    optional
  }) => {
    const isOptionalEverywhere = optional && currentDependencies.every(({
      optional,
      mappedName: addedMappedName
    }) => {
      return addedMappedName !== mappedName || optional;
    });
    return {
      serviceName,
      mappedName,
      optional: isOptionalEverywhere
    };
  })).map(stringifyDependencyDeclaration);
  return inject(dedupedDependencies, initializer);
}
export function extra(extraInformations, initializer, merge = false) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.EXTRA]: merge ? Object.assign(initializer[SPECIAL_PROPS.EXTRA] || {}, extraInformations) : extraInformations
  });
  debug('Wrapped an initializer with extra informations:', extraInformations);
  return uniqueInitializer;
}
export function options(options, initializer, merge = true) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.OPTIONS]: merge ? Object.assign({}, initializer[SPECIAL_PROPS.OPTIONS] || {}, options) : options
  });
  debug('Wrapped an initializer with options:', options);
  return uniqueInitializer;
}
export function name(name, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.NAME]: name
  });
  debug('Wrapped an initializer with a name:', name);
  return uniqueInitializer;
}
export function autoName(initializer) {
  return name(readFunctionName(initializer), initializer);
}

function readFunctionName(aFunction) {
  if (typeof aFunction !== 'function') {
    throw new YError('E_AUTO_NAMING_FAILURE', typeof aFunction);
  }

  const functionName = parseName(aFunction.name || '');

  if (!functionName) {
    throw new YError('E_AUTO_NAMING_FAILURE', aFunction.name);
  }

  return functionName;
}

export function parseName(functionName) {
  return functionName.split(' ').pop().replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());
}
export function type(type, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
    [SPECIAL_PROPS.TYPE]: type
  });
  debug('Wrapped an initializer with a type:', type);
  return uniqueInitializer;
}
export function initializer(properties, initializer) {
  const uniqueInitializer = reuseSpecialProps(initializer, initializer, Object.keys(properties).reduce((finalProperties, property) => {
    const finalProperty = SPECIAL_PROPS_PREFIX + property;

    if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {
      throw new YError('E_BAD_PROPERTY', property);
    }

    finalProperties[finalProperty] = properties[property];
    return finalProperties;
  }, {}));
  debug('Wrapped an initializer with properties:', properties);
  return uniqueInitializer;
}
export function constant(name, value) {
  const contantLooksLikeAnInitializer = value instanceof Function && value[SPECIAL_PROPS.INJECT];

  if (contantLooksLikeAnInitializer) {
    throw new YError(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);
  }

  const uniqueInitializer = initializer({
    name: name,
    type: 'constant',
    options: {
      singleton: true
    },
    inject: [],
    value: value
  }, deliverConstantValue.bind(null, value));
  debug(`Created an initializer from a constant: ${name}.`);
  return uniqueInitializer;
}
export function service(builder, name, dependencies, options) {
  if (!builder) {
    throw new YError('E_NO_SERVICE_BUILDER');
  }

  const uniqueInitializer = reuseSpecialProps(builder, builder, {
    [SPECIAL_PROPS.NAME]: name,
    [SPECIAL_PROPS.TYPE]: 'service',
    [SPECIAL_PROPS.INJECT]: dependencies,
    [SPECIAL_PROPS.OPTIONS]: options
  });
  debug(`Created an initializer from a service builder: ${name || 'anonymous'}.`);
  return uniqueInitializer;
}
export function autoService(serviceBuilder) {
  const name = readFunctionName(serviceBuilder);
  const source = serviceBuilder.toString();
  const dependencies = parseInjections(source, {
    allowEmpty: true
  });
  return initializer({
    name,
    type: 'service',
    inject: dependencies
  }, serviceBuilder);
}
export function provider(builder, name, dependencies, options) {
  if (!builder) {
    throw new YError('E_NO_PROVIDER_BUILDER');
  }

  const uniqueInitializer = reuseSpecialProps(builder, builder, {
    [SPECIAL_PROPS.NAME]: name,
    [SPECIAL_PROPS.TYPE]: 'provider',
    [SPECIAL_PROPS.INJECT]: dependencies,
    [SPECIAL_PROPS.OPTIONS]: options
  });
  debug(`Created an initializer from a provider builder: ${name || 'anonymous'}.`);
  return uniqueInitializer;
}
export function autoProvider(providerBuilder) {
  const name = readFunctionName(providerBuilder);
  const source = providerBuilder.toString();
  const dependencies = parseInjections(source, {
    allowEmpty: true
  });
  return initializer({
    name,
    type: 'provider',
    inject: dependencies
  }, providerBuilder);
}

async function deliverConstantValue(value) {
  return value;
}

export function handler(handlerFunction, name, dependencies, options) {
  name = name || handlerFunction[SPECIAL_PROPS.NAME];
  dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT];

  if (!name) {
    throw new YError('E_NO_HANDLER_NAME', handlerFunction);
  }

  return initializer({
    name,
    type: 'service',
    inject: dependencies,
    options
  }, async (...args) => handlerFunction.bind(null, ...args));
}
export function autoHandler(handlerFunction) {
  const name = readFunctionName(handlerFunction);
  const source = handlerFunction.toString();
  const dependencies = parseInjections(source);
  return initializer({
    name,
    type: 'service',
    inject: dependencies
  }, async (...args) => handlerFunction.bind(null, ...args));
}
export function parseDependencyDeclaration(dependencyDeclaration) {
  const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);
  const [serviceName, mappedName] = (optional ? dependencyDeclaration.slice(1) : dependencyDeclaration).split(DECLARATION_SEPARATOR);
  return {
    serviceName,
    mappedName: mappedName || serviceName,
    optional
  };
}
export function stringifyDependencyDeclaration(dependencyDeclarationParts) {
  return `${dependencyDeclarationParts.optional ? '?' : ''}${dependencyDeclarationParts.serviceName}${dependencyDeclarationParts.mappedName !== dependencyDeclarationParts.serviceName ? '>' + dependencyDeclarationParts.mappedName : ''}`;
}
//# sourceMappingURL=util.mjs.map