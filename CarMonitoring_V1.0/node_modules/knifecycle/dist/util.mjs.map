{"version":3,"sources":["../src/util.js"],"names":["YError","initDebug","debug","SPECIAL_PROPS_PREFIX","SPECIAL_PROPS","INJECT","OPTIONS","NAME","TYPE","EXTRA","VALUE","ALLOWED_SPECIAL_PROPS","Object","keys","map","key","DECLARATION_SEPARATOR","OPTIONAL_FLAG","ALLOWED_INITIALIZER_TYPES","E_BAD_INJECT_IN_CONSTANT","E_CONSTANT_INJECTION","reuseSpecialProps","from","to","amend","Set","concat","filter","prop","startsWith","reduce","fn","value","Array","assign","bind","wrapInitializer","wrapper","baseInitializer","services","baseInstance","inject","dependencies","initializer","uniqueInitializer","useInject","mergeInject","alsoInject","autoInject","source","toString","parseInjections","allowEmpty","matches","match","trim","replace","split","s","injection","includes","shift","test","currentDependencies","parseDependencyDeclaration","addedDependencies","dedupedDependencies","serviceName","declarationIsOverridden","some","addedServiceName","mappedName","optional","isOptionalEverywhere","every","addedMappedName","stringifyDependencyDeclaration","extra","extraInformations","merge","options","name","autoName","readFunctionName","aFunction","functionName","parseName","pop","_","$1","toLowerCase","type","properties","finalProperties","property","finalProperty","constant","contantLooksLikeAnInitializer","Function","singleton","deliverConstantValue","service","builder","autoService","serviceBuilder","provider","autoProvider","providerBuilder","handler","handlerFunction","args","autoHandler","dependencyDeclaration","slice","dependencyDeclarationParts"],"mappings":"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","sourcesContent":["import YError from 'yerror';\nimport initDebug from 'debug';\n\nconst debug = initDebug('knifecycle');\n\n/* Architecture Note #1.2: Creating initializers\n\n`knifecycle` uses initializers at its a core. An initializer is basically\n an asynchronous function with some annotations:\n- name: it uniquely identifies the initializer so that it can be\n referred to as another initializer dependency.\n- type: an initializer can be of three types at the moment\n (constant, service or provider). The initializer annotations\n varies accordsing to those types as we'll see later on.\n- injected dependencies: an array of dependencies declarations that\n declares which initializer htis initializer depends on. Constants\n logically cannot have dependencies.\n- options: various options like for exemple, if the initializer\n implements the singleton pattern or not.\n- value: only used for constant, this property allows to know\n the value the initializer resolves to without actually executing it.\n- extra: an extra property for custom use that will be propagated\n by the various other decorators you'll find in this library.\n\n`Knifecycle` provides a set of decorators that allows you to simply\n create new initializers.\n*/\nexport const SPECIAL_PROPS_PREFIX = '$';\nexport const SPECIAL_PROPS = {\n  INJECT: `${SPECIAL_PROPS_PREFIX}inject`,\n  OPTIONS: `${SPECIAL_PROPS_PREFIX}options`,\n  NAME: `${SPECIAL_PROPS_PREFIX}name`,\n  TYPE: `${SPECIAL_PROPS_PREFIX}type`,\n  EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,\n  VALUE: `${SPECIAL_PROPS_PREFIX}value`,\n};\nexport const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map(\n  (key) => SPECIAL_PROPS[key],\n);\nexport const DECLARATION_SEPARATOR = '>';\nexport const OPTIONAL_FLAG = '?';\nexport const ALLOWED_INITIALIZER_TYPES = ['provider', 'service', 'constant'];\n\nconst E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';\nconst E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';\n\n/**\n * Apply special props to the given function from another one\n * @param  {Function} from The initialization function in which to pick the props\n * @param  {Function} to   The initialization function from which to build the new one\n * @param  {Object}   [amend={}]   Some properties to override\n * @return {Function}      The newly built function\n */\nexport function reuseSpecialProps(from, to, amend = {}) {\n  return [...new Set(Object.keys(from).concat(Object.keys(amend)))]\n    .filter((prop) => prop.startsWith(SPECIAL_PROPS_PREFIX))\n    .reduce((fn, prop) => {\n      const value =\n        'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];\n      if (value instanceof Array) {\n        fn[prop] = value.concat();\n      } else if (value instanceof Object) {\n        fn[prop] = Object.assign({}, value);\n      } else {\n        fn[prop] = value;\n      }\n      return fn;\n    }, to.bind());\n}\n\n/**\n * Allows to wrap an initializer to add extra initialization steps\n * @param  {Function} wrapper\n * A function taking dependencies and the base\n * service in arguments\n * @param  {Function} baseInitializer\n * The initializer to decorate\n * @return {Function}\n * The new initializer\n */\nexport function wrapInitializer(wrapper, baseInitializer) {\n  return reuseSpecialProps(baseInitializer, async (services) => {\n    const baseInstance = await baseInitializer(services);\n\n    return wrapper(services, baseInstance);\n  });\n}\n\n/**\n * Decorator creating a new initializer with different\n *  dependencies declarations set to it.\n * @param  {Array<String>}  dependencies\n * List of dependencies declarations to declare which\n *  services the initializer needs to resolve its\n *  own service\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { inject } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n *  .register(\n *    service(\n *      inject(['ENV'], myServiceInitializer)\n *      'myService',\n *    )\n *   )\n * );\n */\nexport function inject(dependencies, initializer) {\n  if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {\n    throw new YError(\n      E_BAD_INJECT_IN_CONSTANT,\n      initializer[SPECIAL_PROPS.NAME],\n      dependencies,\n    );\n  }\n\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.INJECT]: dependencies,\n  });\n\n  debug('Wrapped an initializer with dependencies:', dependencies);\n\n  return uniqueInitializer;\n}\n\n/**\n * Apply injected dependencies from the given initializer to another one\n * @param  {Function} from The initialization function in which to pick the dependencies\n * @param  {Function} to   The destination initialization function\n * @return {Function}      The newly built initialization function\n */\nexport function useInject(from, to) {\n  return inject(from[SPECIAL_PROPS.INJECT] || [], to);\n}\n\n/**\n * Merge injected dependencies of the given initializer with another one\n * @param  {Function} from The initialization function in which to pick the dependencies\n * @param  {Function} to   The destination initialization function\n * @return {Function}      The newly built initialization function\n */\nexport function mergeInject(from, to) {\n  return alsoInject(from[SPECIAL_PROPS.INJECT] || [], to);\n}\n\n/**\n * Decorator creating a new initializer with different\n *  dependencies declarations set to it according to the\n *  given function signature.\n * @param  {Function}  initializer\n * The original initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { autoInject, name } from 'knifecycle'\n *\n * new Knifecycle()\n *   .register(\n *     name(\n *       'application',\n *       autoInject(\n *         async ({ NODE_ENV, mysql: db }) =>\n *           async () => db.query('SELECT applicationId FROM applications WHERE environment=?', [NODE_ENV])\n *         )\n *       )\n *     )\n *   )\n * );\n */\nexport function autoInject(initializer) {\n  const source = initializer.toString();\n  const dependencies = parseInjections(source);\n\n  return inject(dependencies, initializer);\n}\n\nexport function parseInjections(\n  source,\n  { allowEmpty = false } = { allowEmpty: false },\n) {\n  const matches = source.match(\n    /^\\s*(?:async\\s+function(?:\\s+\\w+)?|async)\\s*\\(\\s*\\{\\s*([^{}]+)(\\s*\\.\\.\\.[^{}]+|)\\s*\\}/,\n  );\n\n  if (!matches) {\n    if (!source.match(/^\\s*async/)) {\n      throw new YError('E_NON_ASYNC_INITIALIZER', source);\n    }\n    if (\n      allowEmpty &&\n      source.match(/^\\s*(?:async\\s+function(?:\\s+\\w+)?|async)\\s*\\(\\s*\\)/)\n    ) {\n      return [];\n    }\n    throw new YError('E_AUTO_INJECTION_FAILURE', source);\n  }\n\n  return matches[1]\n    .trim()\n    .replace(/,$/, '')\n    .split(/\\s*,\\s*/)\n    .map((s) => s.trim())\n    .filter((s) => !s.startsWith('...'))\n    .map(\n      (injection) =>\n        (injection.includes('=') ? '?' : '') +\n        injection\n          .split(/\\s*=\\s*/)\n          .shift()\n          .split(/\\s*:\\s*/)\n          .shift(),\n    )\n    .filter((injection) => !/[)(\\][]/.test(injection));\n}\n\n/**\n * Decorator creating a new initializer with some\n *  more dependencies declarations appended to it.\n * @param  {Array<String>}  dependencies\n * List of dependencies declarations to append\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { alsoInject } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   alsoInject(['ENV'], myServiceInitializer),\n *   'myService',\n * ));\n */\nexport function alsoInject(dependencies, initializer) {\n  const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(\n    parseDependencyDeclaration,\n  );\n  const addedDependencies = dependencies.map(parseDependencyDeclaration);\n  const dedupedDependencies = currentDependencies\n    .filter(({ serviceName }) => {\n      const declarationIsOverridden = addedDependencies.some(\n        ({ serviceName: addedServiceName }) => {\n          return addedServiceName === serviceName;\n        },\n      );\n\n      return !declarationIsOverridden;\n    })\n    .concat(\n      addedDependencies.map(({ serviceName, mappedName, optional }) => {\n        const isOptionalEverywhere =\n          optional &&\n          currentDependencies.every(\n            ({ optional, mappedName: addedMappedName }) => {\n              return addedMappedName !== mappedName || optional;\n            },\n          );\n        return {\n          serviceName,\n          mappedName,\n          optional: isOptionalEverywhere,\n        };\n      }),\n    )\n    .map(stringifyDependencyDeclaration);\n\n  return inject(dedupedDependencies, initializer);\n}\n\n/**\n * Decorator creating a new initializer with some\n *  extra informations appended to it. It is just\n *  a way for user to store some additional\n *  informations but has no interaction with the\n *  Knifecycle internals.\n * @param  {Object}  extraInformations\n * An object containing those extra informations.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @param  {Boolean}   [merge=false]\n * Whether the extra object should be merged\n * with the existing one or not\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { extra } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   extra({ httpHandler: true }, myServiceInitializer),\n *   'myService',\n * ));\n */\nexport function extra(extraInformations, initializer, merge = false) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.EXTRA]: merge\n      ? Object.assign(initializer[SPECIAL_PROPS.EXTRA] || {}, extraInformations)\n      : extraInformations,\n  });\n\n  debug('Wrapped an initializer with extra informations:', extraInformations);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to amend an initializer options.\n * @param  {Object}    options\n * Options to set to the initializer\n * @param  {Object}    options.singleton\n * Define the initializer service as a singleton\n * (one instance for several runs)\n * @param  {Function}  initializer\n * The initializer to tweak\n * @param  {Function}  [merge=true]\n * Whether options should be merged or not\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { inject, options } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   inject(['ENV'],\n *     options({ singleton: true}, myServiceInitializer)\n *   ),\n *   'myService',\n * ));\n */\nexport function options(options, initializer, merge = true) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.OPTIONS]: merge\n      ? Object.assign({}, initializer[SPECIAL_PROPS.OPTIONS] || {}, options)\n      : options,\n  });\n\n  debug('Wrapped an initializer with options:', options);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer name.\n * @param  {String}    name\n * The name of the service the initializer resolves to.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer with that name set\n * @example\n *\n * import Knifecycle, { name } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(name('myService', myServiceInitializer));\n */\nexport function name(name, initializer) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.NAME]: name,\n  });\n\n  debug('Wrapped an initializer with a name:', name);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer name from its function name.\n * @param  {Function}  initializer\n * The initializer to name\n * @return {Function}\n * Returns a new initializer with that name set\n * @example\n *\n * import Knifecycle, { autoName } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(autoName(async function myService() {}));\n */\nexport function autoName(initializer) {\n  return name(readFunctionName(initializer), initializer);\n}\n\nfunction readFunctionName(aFunction) {\n  if (typeof aFunction !== 'function') {\n    throw new YError('E_AUTO_NAMING_FAILURE', typeof aFunction);\n  }\n\n  const functionName = parseName(aFunction.name || '');\n\n  if (!functionName) {\n    throw new YError('E_AUTO_NAMING_FAILURE', aFunction.name);\n  }\n\n  return functionName;\n}\n\nexport function parseName(functionName) {\n  return functionName\n    .split(' ')\n    .pop()\n    .replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());\n}\n\n/**\n * Decorator to set an initializer type.\n * @param  {String}    type\n * The type to set to the initializer.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { name, type } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(\n *   type('service',\n *     name('myService',\n *       myServiceInitializer\n *     )\n *   )\n * );\n */\nexport function type(type, initializer) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.TYPE]: type,\n  });\n\n  debug('Wrapped an initializer with a type:', type);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer properties.\n * @param  {Object}    properties\n * Properties to set to the service.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { initializer } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(initializer({\n *   name: 'myService',\n *   type: 'service',\n *   inject: ['ENV'],\n *   options: { singleton: true }\n * }, myServiceInitializer));\n */\nexport function initializer(properties, initializer) {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer,\n    Object.keys(properties).reduce((finalProperties, property) => {\n      const finalProperty = SPECIAL_PROPS_PREFIX + property;\n\n      if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {\n        throw new YError('E_BAD_PROPERTY', property);\n      }\n      finalProperties[finalProperty] = properties[property];\n      return finalProperties;\n    }, {}),\n  );\n\n  debug('Wrapped an initializer with properties:', properties);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that creates an initializer for a constant value\n * @param  {String}    name\n * The constant's name.\n * @param  {any}  initializer\n * The constant's value\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { constant, service } from 'knifecycle';\n *\n * const { printAnswer } = new Knifecycle()\n *   .register(constant('THE_NUMBER', value))\n *   .register(constant('log', console.log.bind(console)))\n *   .register(service(\n *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),\n *     'printAnswer',\n *     ['THE_NUMBER', 'log'],\n *   ))\n *   .run(['printAnswer']);\n *\n * printAnswer(); // 42\n */\nexport function constant(name, value) {\n  const contantLooksLikeAnInitializer =\n    value instanceof Function && value[SPECIAL_PROPS.INJECT];\n\n  if (contantLooksLikeAnInitializer) {\n    throw new YError(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);\n  }\n\n  const uniqueInitializer = initializer(\n    {\n      name: name,\n      type: 'constant',\n      options: { singleton: true },\n      inject: [],\n      value: value,\n    },\n    deliverConstantValue.bind(null, value),\n  );\n\n  debug(`Created an initializer from a constant: ${name}.`);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that creates an initializer for a service\n * @param  {Function}   builder\n * An initializer returning the service promise\n * @param  {String}    [name]\n * The service's name\n * @param  {Array<String>}    [dependencies]\n * The service's dependencies\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { constant, service } from 'knifecycle';\n *\n * const { printAnswer } = new Knifecycle()\n *   .register(constant('THE_NUMBER', value))\n *   .register(constant('log', console.log.bind(console)))\n *   .register(service(\n *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),\n *     'printAnswer',\n *     ['THE_NUMBER', 'log'],\n *     { singleton: true }\n *   ))\n *   .run(['printAnswer']);\n *\n * printAnswer(); // 42\n */\nexport function service(builder, name, dependencies, options) {\n  if (!builder) {\n    throw new YError('E_NO_SERVICE_BUILDER');\n  }\n  const uniqueInitializer = reuseSpecialProps(builder, builder, {\n    [SPECIAL_PROPS.NAME]: name,\n    [SPECIAL_PROPS.TYPE]: 'service',\n    [SPECIAL_PROPS.INJECT]: dependencies,\n    [SPECIAL_PROPS.OPTIONS]: options,\n  });\n\n  debug(\n    `Created an initializer from a service builder: ${name || 'anonymous'}.`,\n  );\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that auto creates a service\n * @param  {Function}   initializer\n * An initializer returning the service promise\n * @return {Function}\n * Returns a new initializer\n */\nexport function autoService(serviceBuilder) {\n  const name = readFunctionName(serviceBuilder);\n  const source = serviceBuilder.toString();\n  const dependencies = parseInjections(source, { allowEmpty: true });\n\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n    },\n    serviceBuilder,\n  );\n}\n\n/**\n * Decorator that creates an initializer for a provider\n * @param  {Function}   builder\n * A builder returning the provider promise\n * @param  {String}    [name]\n * The service's name\n * @param  {Array<String>}    [dependencies]\n * The service's dependencies\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { provider } from 'knifecycle'\n * import fs from 'fs';\n *\n * const $ = new Knifecycle();\n *\n * $.register(provider(configProvider, 'config'));\n *\n * async function configProvider() {\n *   return new Promise((resolve, reject) {\n *     fs.readFile('config.js', function(err, data) {\n *       let config;\n *\n *       if(err) {\n *         reject(err);\n *         return;\n *       }\n *\n *       try {\n *         config = JSON.parse(data.toString);\n *       } catch (err) {\n *         reject(err);\n *         return;\n *       }\n *\n *       resolve({\n *         service: config,\n *       });\n *     });\n *   });\n * }\n */\nexport function provider(builder, name, dependencies, options) {\n  if (!builder) {\n    throw new YError('E_NO_PROVIDER_BUILDER');\n  }\n\n  const uniqueInitializer = reuseSpecialProps(builder, builder, {\n    [SPECIAL_PROPS.NAME]: name,\n    [SPECIAL_PROPS.TYPE]: 'provider',\n    [SPECIAL_PROPS.INJECT]: dependencies,\n    [SPECIAL_PROPS.OPTIONS]: options,\n  });\n\n  debug(\n    `Created an initializer from a provider builder: ${name || 'anonymous'}.`,\n  );\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that auto creates a provider\n * @param  {Function}   initializer\n * An initializer returning the provider promise\n * @return {Function}\n * Returns a new initializer\n */\nexport function autoProvider(providerBuilder) {\n  const name = readFunctionName(providerBuilder);\n  const source = providerBuilder.toString();\n  const dependencies = parseInjections(source, { allowEmpty: true });\n\n  return initializer(\n    {\n      name,\n      type: 'provider',\n      inject: dependencies,\n    },\n    providerBuilder,\n  );\n}\n\nasync function deliverConstantValue(value) {\n  return value;\n}\n\n/**\n * Shortcut to create an initializer with a simple handler\n * @param  {Function} handlerFunction\n * The handler function\n * @param  {String}  [name]\n * The name of the handler. Default to the DI prop if exists\n * @param  {Array<String>}  [dependencies=[]]\n * The dependencies to inject in it\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { handler } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(handler(getUser, 'getUser', ['db', '?log']));\n *\n * const QUERY = `SELECT * FROM users WHERE id=$1`\n * async function getUser({ db }, userId) {\n *   const [row] = await db.query(QUERY, userId);\n *\n *   return row;\n * }\n */\nexport function handler(handlerFunction, name, dependencies, options) {\n  name = name || handlerFunction[SPECIAL_PROPS.NAME];\n  dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT];\n\n  if (!name) {\n    throw new YError('E_NO_HANDLER_NAME', handlerFunction);\n  }\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n      options,\n    },\n    async (...args) => handlerFunction.bind(null, ...args),\n  );\n}\n\n/**\n * Allows to create an initializer with a simple handler automagically\n * @param  {Function} handlerFunction\n * The handler function\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { autoHandler } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(autoHandler(getUser));\n *\n * const QUERY = `SELECT * FROM users WHERE id=$1`\n * async function getUser({ db }, userId) {\n *   const [row] = await db.query(QUERY, userId);\n *\n *   return row;\n * }\n */\nexport function autoHandler(handlerFunction) {\n  const name = readFunctionName(handlerFunction);\n  const source = handlerFunction.toString();\n  const dependencies = parseInjections(source);\n\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n    },\n    async (...args) => handlerFunction.bind(null, ...args),\n  );\n}\n\n/* Architecture Note #1.2.1: Dependencies declaration syntax\n\nThe dependencies syntax is of the following form:\n `?serviceName>mappedName`\nThe `?` flag indicates an optional dependency.\n `>mappedName` is optional and allows to inject\n `mappedName` as `serviceName`.\nIt allows to write generic services with fixed\n dependencies and remap their name at injection time.\n*/\n\n/**\n * Explode a dependency declaration an returns its parts.\n * @param  {String}  dependencyDeclaration\n * A dependency declaration string\n * @return {Object}\n * The various parts of it\n * @example\n * parseDependencyDeclaration('pgsql>db');\n * // Returns\n * {\n *   serviceName: 'pgsql',\n *   mappedName: 'db',\n *   optional: false,\n * }\n */\nexport function parseDependencyDeclaration(dependencyDeclaration) {\n  const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);\n  const [serviceName, mappedName] = (optional\n    ? dependencyDeclaration.slice(1)\n    : dependencyDeclaration\n  ).split(DECLARATION_SEPARATOR);\n\n  return {\n    serviceName,\n    mappedName: mappedName || serviceName,\n    optional,\n  };\n}\n\n/**\n * Stringify a dependency declaration from its parts.\n * @param  {Object}  dependencyDeclarationParts\n * A dependency declaration string\n * @return {String}\n * The various parts of it\n * @example\n * stringifyDependencyDeclaration({\n *   serviceName: 'pgsql',\n *   mappedName: 'db',\n *   optional: false,\n * });\n *\n * // Returns\n * 'pgsql>db'\n */\nexport function stringifyDependencyDeclaration(dependencyDeclarationParts) {\n  return `${dependencyDeclarationParts.optional ? '?' : ''}${\n    dependencyDeclarationParts.serviceName\n  }${\n    dependencyDeclarationParts.mappedName !==\n    dependencyDeclarationParts.serviceName\n      ? '>' + dependencyDeclarationParts.mappedName\n      : ''\n  }`;\n}\n"],"file":"util.mjs"}