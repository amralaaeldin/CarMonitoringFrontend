{"version":3,"sources":["../src/sequence.js"],"names":["YError","MAX_ITERATIONS","buildInitializationSequence","rootNode","batches","i","batch","recursivelyGetNextSequenceBatch","length","push","node","nodeIsALeaf","__childNodes","nodeIsInBatches","every","bind","concat","__name","reduce","childNode","Set","some","includes"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AAEA,MAAMC,cAAc,GAAG,EAAvB;AAEA,OAAO,SAASC,2BAAT,CAAqCC,QAArC,EAA+C;AACpD,QAAMC,OAAO,GAAG,EAAhB;AACA,MAAIC,CAAC,GAAG,CAAR;;AAEA,SAAOA,CAAC,GAAGJ,cAAX,EAA2B;AACzB,UAAMK,KAAK,GAAGC,+BAA+B,CAACJ,QAAD,EAAWC,OAAX,CAA7C;;AAEA,QAAI,MAAME,KAAK,CAACE,MAAhB,EAAwB;AACtB;AACD;;AACDJ,IAAAA,OAAO,CAACK,IAAR,CAAaH,KAAb;AACAD,IAAAA,CAAC;AACF;;AAED,MAAIA,CAAC,KAAKJ,cAAV,EAA0B;AACxB,UAAM,IAAID,MAAJ,CAAW,gCAAX,CAAN;AACD;;AAED,SAAOI,OAAP;AACD;;AAED,SAASG,+BAAT,CAAyCG,IAAzC,EAA+CN,OAA/C,EAAwDE,KAAK,GAAG,EAAhE,EAAoE;AAClE,QAAMK,WAAW,GAAG,EAAED,IAAI,CAACE,YAAL,IAAqBF,IAAI,CAACE,YAAL,CAAkBJ,MAAzC,CAApB;;AAEA,MAAIK,eAAe,CAACT,OAAD,EAAUM,IAAV,CAAnB,EAAoC;AAClC,WAAOJ,KAAP;AACD;;AAED,MACEK,WAAW,IACXD,IAAI,CAACE,YAAL,CAAkBE,KAAlB,CAAwBD,eAAe,CAACE,IAAhB,CAAqB,IAArB,EAA2BX,OAA3B,CAAxB,CAFF,EAGE;AACA,WAAOE,KAAK,CAACU,MAAN,CAAaN,IAAI,CAACO,MAAlB,CAAP;AACD;;AAED,SAAOP,IAAI,CAACE,YAAL,CAAkBM,MAAlB,CACL,CAACZ,KAAD,EAAQa,SAAR,KAAsB,CACpB,GAAG,IAAIC,GAAJ,CAAQb,+BAA+B,CAACY,SAAD,EAAYf,OAAZ,EAAqBE,KAArB,CAAvC,CADiB,CADjB,EAILA,KAJK,CAAP;AAMD;;AAED,SAASO,eAAT,CAAyBT,OAAzB,EAAkCM,IAAlC,EAAwC;AACtC,SAAON,OAAO,CAACiB,IAAR,CAAcf,KAAD,IAAWA,KAAK,CAACgB,QAAN,CAAeZ,IAAI,CAACO,MAApB,CAAxB,CAAP;AACD","sourcesContent":["import YError from 'yerror';\n\nconst MAX_ITERATIONS = 99;\n\nexport function buildInitializationSequence(rootNode) {\n  const batches = [];\n  let i = 0;\n\n  while (i < MAX_ITERATIONS) {\n    const batch = recursivelyGetNextSequenceBatch(rootNode, batches);\n\n    if (0 === batch.length) {\n      break;\n    }\n    batches.push(batch);\n    i++;\n  }\n\n  if (i === MAX_ITERATIONS) {\n    throw new YError('E_PROBABLE_CIRCULAR_DEPENDENCY');\n  }\n\n  return batches;\n}\n\nfunction recursivelyGetNextSequenceBatch(node, batches, batch = []) {\n  const nodeIsALeaf = !(node.__childNodes && node.__childNodes.length);\n\n  if (nodeIsInBatches(batches, node)) {\n    return batch;\n  }\n\n  if (\n    nodeIsALeaf ||\n    node.__childNodes.every(nodeIsInBatches.bind(null, batches))\n  ) {\n    return batch.concat(node.__name);\n  }\n\n  return node.__childNodes.reduce(\n    (batch, childNode) => [\n      ...new Set(recursivelyGetNextSequenceBatch(childNode, batches, batch)),\n    ],\n    batch,\n  );\n}\n\nfunction nodeIsInBatches(batches, node) {\n  return batches.some((batch) => batch.includes(node.__name));\n}\n"],"file":"sequence.mjs"}