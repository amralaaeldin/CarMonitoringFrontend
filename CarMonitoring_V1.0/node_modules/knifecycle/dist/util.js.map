{"version":3,"sources":["../src/util.js"],"names":["debug","SPECIAL_PROPS_PREFIX","SPECIAL_PROPS","INJECT","OPTIONS","NAME","TYPE","EXTRA","VALUE","ALLOWED_SPECIAL_PROPS","Object","keys","map","key","DECLARATION_SEPARATOR","OPTIONAL_FLAG","ALLOWED_INITIALIZER_TYPES","E_BAD_INJECT_IN_CONSTANT","E_CONSTANT_INJECTION","reuseSpecialProps","from","to","amend","Set","concat","filter","prop","startsWith","reduce","fn","value","Array","assign","bind","wrapInitializer","wrapper","baseInitializer","services","baseInstance","inject","dependencies","initializer","YError","uniqueInitializer","useInject","mergeInject","alsoInject","autoInject","source","toString","parseInjections","allowEmpty","matches","match","trim","replace","split","s","injection","includes","shift","test","currentDependencies","parseDependencyDeclaration","addedDependencies","dedupedDependencies","serviceName","declarationIsOverridden","some","addedServiceName","mappedName","optional","isOptionalEverywhere","every","addedMappedName","stringifyDependencyDeclaration","extra","extraInformations","merge","options","name","autoName","readFunctionName","aFunction","functionName","parseName","pop","_","$1","toLowerCase","type","properties","finalProperties","property","finalProperty","constant","contantLooksLikeAnInitializer","Function","singleton","deliverConstantValue","service","builder","autoService","serviceBuilder","provider","autoProvider","providerBuilder","handler","handlerFunction","args","autoHandler","dependencyDeclaration","slice","dependencyDeclarationParts"],"mappings":"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","sourcesContent":["import YError from 'yerror';\nimport initDebug from 'debug';\n\nconst debug = initDebug('knifecycle');\n\n/* Architecture Note #1.2: Creating initializers\n\n`knifecycle` uses initializers at its a core. An initializer is basically\n an asynchronous function with some annotations:\n- name: it uniquely identifies the initializer so that it can be\n referred to as another initializer dependency.\n- type: an initializer can be of three types at the moment\n (constant, service or provider). The initializer annotations\n varies accordsing to those types as we'll see later on.\n- injected dependencies: an array of dependencies declarations that\n declares which initializer htis initializer depends on. Constants\n logically cannot have dependencies.\n- options: various options like for exemple, if the initializer\n implements the singleton pattern or not.\n- value: only used for constant, this property allows to know\n the value the initializer resolves to without actually executing it.\n- extra: an extra property for custom use that will be propagated\n by the various other decorators you'll find in this library.\n\n`Knifecycle` provides a set of decorators that allows you to simply\n create new initializers.\n*/\nexport const SPECIAL_PROPS_PREFIX = '$';\nexport const SPECIAL_PROPS = {\n  INJECT: `${SPECIAL_PROPS_PREFIX}inject`,\n  OPTIONS: `${SPECIAL_PROPS_PREFIX}options`,\n  NAME: `${SPECIAL_PROPS_PREFIX}name`,\n  TYPE: `${SPECIAL_PROPS_PREFIX}type`,\n  EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,\n  VALUE: `${SPECIAL_PROPS_PREFIX}value`,\n};\nexport const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map(\n  (key) => SPECIAL_PROPS[key],\n);\nexport const DECLARATION_SEPARATOR = '>';\nexport const OPTIONAL_FLAG = '?';\nexport const ALLOWED_INITIALIZER_TYPES = ['provider', 'service', 'constant'];\n\nconst E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';\nconst E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';\n\n/**\n * Apply special props to the given function from another one\n * @param  {Function} from The initialization function in which to pick the props\n * @param  {Function} to   The initialization function from which to build the new one\n * @param  {Object}   [amend={}]   Some properties to override\n * @return {Function}      The newly built function\n */\nexport function reuseSpecialProps(from, to, amend = {}) {\n  return [...new Set(Object.keys(from).concat(Object.keys(amend)))]\n    .filter((prop) => prop.startsWith(SPECIAL_PROPS_PREFIX))\n    .reduce((fn, prop) => {\n      const value =\n        'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];\n      if (value instanceof Array) {\n        fn[prop] = value.concat();\n      } else if (value instanceof Object) {\n        fn[prop] = Object.assign({}, value);\n      } else {\n        fn[prop] = value;\n      }\n      return fn;\n    }, to.bind());\n}\n\n/**\n * Allows to wrap an initializer to add extra initialization steps\n * @param  {Function} wrapper\n * A function taking dependencies and the base\n * service in arguments\n * @param  {Function} baseInitializer\n * The initializer to decorate\n * @return {Function}\n * The new initializer\n */\nexport function wrapInitializer(wrapper, baseInitializer) {\n  return reuseSpecialProps(baseInitializer, async (services) => {\n    const baseInstance = await baseInitializer(services);\n\n    return wrapper(services, baseInstance);\n  });\n}\n\n/**\n * Decorator creating a new initializer with different\n *  dependencies declarations set to it.\n * @param  {Array<String>}  dependencies\n * List of dependencies declarations to declare which\n *  services the initializer needs to resolve its\n *  own service\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { inject } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n *  .register(\n *    service(\n *      inject(['ENV'], myServiceInitializer)\n *      'myService',\n *    )\n *   )\n * );\n */\nexport function inject(dependencies, initializer) {\n  if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {\n    throw new YError(\n      E_BAD_INJECT_IN_CONSTANT,\n      initializer[SPECIAL_PROPS.NAME],\n      dependencies,\n    );\n  }\n\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.INJECT]: dependencies,\n  });\n\n  debug('Wrapped an initializer with dependencies:', dependencies);\n\n  return uniqueInitializer;\n}\n\n/**\n * Apply injected dependencies from the given initializer to another one\n * @param  {Function} from The initialization function in which to pick the dependencies\n * @param  {Function} to   The destination initialization function\n * @return {Function}      The newly built initialization function\n */\nexport function useInject(from, to) {\n  return inject(from[SPECIAL_PROPS.INJECT] || [], to);\n}\n\n/**\n * Merge injected dependencies of the given initializer with another one\n * @param  {Function} from The initialization function in which to pick the dependencies\n * @param  {Function} to   The destination initialization function\n * @return {Function}      The newly built initialization function\n */\nexport function mergeInject(from, to) {\n  return alsoInject(from[SPECIAL_PROPS.INJECT] || [], to);\n}\n\n/**\n * Decorator creating a new initializer with different\n *  dependencies declarations set to it according to the\n *  given function signature.\n * @param  {Function}  initializer\n * The original initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { autoInject, name } from 'knifecycle'\n *\n * new Knifecycle()\n *   .register(\n *     name(\n *       'application',\n *       autoInject(\n *         async ({ NODE_ENV, mysql: db }) =>\n *           async () => db.query('SELECT applicationId FROM applications WHERE environment=?', [NODE_ENV])\n *         )\n *       )\n *     )\n *   )\n * );\n */\nexport function autoInject(initializer) {\n  const source = initializer.toString();\n  const dependencies = parseInjections(source);\n\n  return inject(dependencies, initializer);\n}\n\nexport function parseInjections(\n  source,\n  { allowEmpty = false } = { allowEmpty: false },\n) {\n  const matches = source.match(\n    /^\\s*(?:async\\s+function(?:\\s+\\w+)?|async)\\s*\\(\\s*\\{\\s*([^{}]+)(\\s*\\.\\.\\.[^{}]+|)\\s*\\}/,\n  );\n\n  if (!matches) {\n    if (!source.match(/^\\s*async/)) {\n      throw new YError('E_NON_ASYNC_INITIALIZER', source);\n    }\n    if (\n      allowEmpty &&\n      source.match(/^\\s*(?:async\\s+function(?:\\s+\\w+)?|async)\\s*\\(\\s*\\)/)\n    ) {\n      return [];\n    }\n    throw new YError('E_AUTO_INJECTION_FAILURE', source);\n  }\n\n  return matches[1]\n    .trim()\n    .replace(/,$/, '')\n    .split(/\\s*,\\s*/)\n    .map((s) => s.trim())\n    .filter((s) => !s.startsWith('...'))\n    .map(\n      (injection) =>\n        (injection.includes('=') ? '?' : '') +\n        injection\n          .split(/\\s*=\\s*/)\n          .shift()\n          .split(/\\s*:\\s*/)\n          .shift(),\n    )\n    .filter((injection) => !/[)(\\][]/.test(injection));\n}\n\n/**\n * Decorator creating a new initializer with some\n *  more dependencies declarations appended to it.\n * @param  {Array<String>}  dependencies\n * List of dependencies declarations to append\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { alsoInject } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   alsoInject(['ENV'], myServiceInitializer),\n *   'myService',\n * ));\n */\nexport function alsoInject(dependencies, initializer) {\n  const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(\n    parseDependencyDeclaration,\n  );\n  const addedDependencies = dependencies.map(parseDependencyDeclaration);\n  const dedupedDependencies = currentDependencies\n    .filter(({ serviceName }) => {\n      const declarationIsOverridden = addedDependencies.some(\n        ({ serviceName: addedServiceName }) => {\n          return addedServiceName === serviceName;\n        },\n      );\n\n      return !declarationIsOverridden;\n    })\n    .concat(\n      addedDependencies.map(({ serviceName, mappedName, optional }) => {\n        const isOptionalEverywhere =\n          optional &&\n          currentDependencies.every(\n            ({ optional, mappedName: addedMappedName }) => {\n              return addedMappedName !== mappedName || optional;\n            },\n          );\n        return {\n          serviceName,\n          mappedName,\n          optional: isOptionalEverywhere,\n        };\n      }),\n    )\n    .map(stringifyDependencyDeclaration);\n\n  return inject(dedupedDependencies, initializer);\n}\n\n/**\n * Decorator creating a new initializer with some\n *  extra informations appended to it. It is just\n *  a way for user to store some additional\n *  informations but has no interaction with the\n *  Knifecycle internals.\n * @param  {Object}  extraInformations\n * An object containing those extra informations.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @param  {Boolean}   [merge=false]\n * Whether the extra object should be merged\n * with the existing one or not\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { extra } from 'knifecycle'\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   extra({ httpHandler: true }, myServiceInitializer),\n *   'myService',\n * ));\n */\nexport function extra(extraInformations, initializer, merge = false) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.EXTRA]: merge\n      ? Object.assign(initializer[SPECIAL_PROPS.EXTRA] || {}, extraInformations)\n      : extraInformations,\n  });\n\n  debug('Wrapped an initializer with extra informations:', extraInformations);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to amend an initializer options.\n * @param  {Object}    options\n * Options to set to the initializer\n * @param  {Object}    options.singleton\n * Define the initializer service as a singleton\n * (one instance for several runs)\n * @param  {Function}  initializer\n * The initializer to tweak\n * @param  {Function}  [merge=true]\n * Whether options should be merged or not\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { inject, options } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(service(\n *   inject(['ENV'],\n *     options({ singleton: true}, myServiceInitializer)\n *   ),\n *   'myService',\n * ));\n */\nexport function options(options, initializer, merge = true) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.OPTIONS]: merge\n      ? Object.assign({}, initializer[SPECIAL_PROPS.OPTIONS] || {}, options)\n      : options,\n  });\n\n  debug('Wrapped an initializer with options:', options);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer name.\n * @param  {String}    name\n * The name of the service the initializer resolves to.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer with that name set\n * @example\n *\n * import Knifecycle, { name } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(name('myService', myServiceInitializer));\n */\nexport function name(name, initializer) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.NAME]: name,\n  });\n\n  debug('Wrapped an initializer with a name:', name);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer name from its function name.\n * @param  {Function}  initializer\n * The initializer to name\n * @return {Function}\n * Returns a new initializer with that name set\n * @example\n *\n * import Knifecycle, { autoName } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(autoName(async function myService() {}));\n */\nexport function autoName(initializer) {\n  return name(readFunctionName(initializer), initializer);\n}\n\nfunction readFunctionName(aFunction) {\n  if (typeof aFunction !== 'function') {\n    throw new YError('E_AUTO_NAMING_FAILURE', typeof aFunction);\n  }\n\n  const functionName = parseName(aFunction.name || '');\n\n  if (!functionName) {\n    throw new YError('E_AUTO_NAMING_FAILURE', aFunction.name);\n  }\n\n  return functionName;\n}\n\nexport function parseName(functionName) {\n  return functionName\n    .split(' ')\n    .pop()\n    .replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());\n}\n\n/**\n * Decorator to set an initializer type.\n * @param  {String}    type\n * The type to set to the initializer.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { name, type } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(\n *   type('service',\n *     name('myService',\n *       myServiceInitializer\n *     )\n *   )\n * );\n */\nexport function type(type, initializer) {\n  const uniqueInitializer = reuseSpecialProps(initializer, initializer, {\n    [SPECIAL_PROPS.TYPE]: type,\n  });\n\n  debug('Wrapped an initializer with a type:', type);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator to set an initializer properties.\n * @param  {Object}    properties\n * Properties to set to the service.\n * @param  {Function}  initializer\n * The initializer to tweak\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { initializer } from 'knifecycle';\n * import myServiceInitializer from './service';\n *\n * new Knifecycle()\n * .register(initializer({\n *   name: 'myService',\n *   type: 'service',\n *   inject: ['ENV'],\n *   options: { singleton: true }\n * }, myServiceInitializer));\n */\nexport function initializer(properties, initializer) {\n  const uniqueInitializer = reuseSpecialProps(\n    initializer,\n    initializer,\n    Object.keys(properties).reduce((finalProperties, property) => {\n      const finalProperty = SPECIAL_PROPS_PREFIX + property;\n\n      if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {\n        throw new YError('E_BAD_PROPERTY', property);\n      }\n      finalProperties[finalProperty] = properties[property];\n      return finalProperties;\n    }, {}),\n  );\n\n  debug('Wrapped an initializer with properties:', properties);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that creates an initializer for a constant value\n * @param  {String}    name\n * The constant's name.\n * @param  {any}  initializer\n * The constant's value\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { constant, service } from 'knifecycle';\n *\n * const { printAnswer } = new Knifecycle()\n *   .register(constant('THE_NUMBER', value))\n *   .register(constant('log', console.log.bind(console)))\n *   .register(service(\n *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),\n *     'printAnswer',\n *     ['THE_NUMBER', 'log'],\n *   ))\n *   .run(['printAnswer']);\n *\n * printAnswer(); // 42\n */\nexport function constant(name, value) {\n  const contantLooksLikeAnInitializer =\n    value instanceof Function && value[SPECIAL_PROPS.INJECT];\n\n  if (contantLooksLikeAnInitializer) {\n    throw new YError(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);\n  }\n\n  const uniqueInitializer = initializer(\n    {\n      name: name,\n      type: 'constant',\n      options: { singleton: true },\n      inject: [],\n      value: value,\n    },\n    deliverConstantValue.bind(null, value),\n  );\n\n  debug(`Created an initializer from a constant: ${name}.`);\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that creates an initializer for a service\n * @param  {Function}   builder\n * An initializer returning the service promise\n * @param  {String}    [name]\n * The service's name\n * @param  {Array<String>}    [dependencies]\n * The service's dependencies\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { constant, service } from 'knifecycle';\n *\n * const { printAnswer } = new Knifecycle()\n *   .register(constant('THE_NUMBER', value))\n *   .register(constant('log', console.log.bind(console)))\n *   .register(service(\n *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),\n *     'printAnswer',\n *     ['THE_NUMBER', 'log'],\n *     { singleton: true }\n *   ))\n *   .run(['printAnswer']);\n *\n * printAnswer(); // 42\n */\nexport function service(builder, name, dependencies, options) {\n  if (!builder) {\n    throw new YError('E_NO_SERVICE_BUILDER');\n  }\n  const uniqueInitializer = reuseSpecialProps(builder, builder, {\n    [SPECIAL_PROPS.NAME]: name,\n    [SPECIAL_PROPS.TYPE]: 'service',\n    [SPECIAL_PROPS.INJECT]: dependencies,\n    [SPECIAL_PROPS.OPTIONS]: options,\n  });\n\n  debug(\n    `Created an initializer from a service builder: ${name || 'anonymous'}.`,\n  );\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that auto creates a service\n * @param  {Function}   initializer\n * An initializer returning the service promise\n * @return {Function}\n * Returns a new initializer\n */\nexport function autoService(serviceBuilder) {\n  const name = readFunctionName(serviceBuilder);\n  const source = serviceBuilder.toString();\n  const dependencies = parseInjections(source, { allowEmpty: true });\n\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n    },\n    serviceBuilder,\n  );\n}\n\n/**\n * Decorator that creates an initializer for a provider\n * @param  {Function}   builder\n * A builder returning the provider promise\n * @param  {String}    [name]\n * The service's name\n * @param  {Array<String>}    [dependencies]\n * The service's dependencies\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n *\n * import Knifecycle, { provider } from 'knifecycle'\n * import fs from 'fs';\n *\n * const $ = new Knifecycle();\n *\n * $.register(provider(configProvider, 'config'));\n *\n * async function configProvider() {\n *   return new Promise((resolve, reject) {\n *     fs.readFile('config.js', function(err, data) {\n *       let config;\n *\n *       if(err) {\n *         reject(err);\n *         return;\n *       }\n *\n *       try {\n *         config = JSON.parse(data.toString);\n *       } catch (err) {\n *         reject(err);\n *         return;\n *       }\n *\n *       resolve({\n *         service: config,\n *       });\n *     });\n *   });\n * }\n */\nexport function provider(builder, name, dependencies, options) {\n  if (!builder) {\n    throw new YError('E_NO_PROVIDER_BUILDER');\n  }\n\n  const uniqueInitializer = reuseSpecialProps(builder, builder, {\n    [SPECIAL_PROPS.NAME]: name,\n    [SPECIAL_PROPS.TYPE]: 'provider',\n    [SPECIAL_PROPS.INJECT]: dependencies,\n    [SPECIAL_PROPS.OPTIONS]: options,\n  });\n\n  debug(\n    `Created an initializer from a provider builder: ${name || 'anonymous'}.`,\n  );\n\n  return uniqueInitializer;\n}\n\n/**\n * Decorator that auto creates a provider\n * @param  {Function}   initializer\n * An initializer returning the provider promise\n * @return {Function}\n * Returns a new initializer\n */\nexport function autoProvider(providerBuilder) {\n  const name = readFunctionName(providerBuilder);\n  const source = providerBuilder.toString();\n  const dependencies = parseInjections(source, { allowEmpty: true });\n\n  return initializer(\n    {\n      name,\n      type: 'provider',\n      inject: dependencies,\n    },\n    providerBuilder,\n  );\n}\n\nasync function deliverConstantValue(value) {\n  return value;\n}\n\n/**\n * Shortcut to create an initializer with a simple handler\n * @param  {Function} handlerFunction\n * The handler function\n * @param  {String}  [name]\n * The name of the handler. Default to the DI prop if exists\n * @param  {Array<String>}  [dependencies=[]]\n * The dependencies to inject in it\n * @param  {Object}    [options]\n * Options attached to the built initializer\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { handler } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(handler(getUser, 'getUser', ['db', '?log']));\n *\n * const QUERY = `SELECT * FROM users WHERE id=$1`\n * async function getUser({ db }, userId) {\n *   const [row] = await db.query(QUERY, userId);\n *\n *   return row;\n * }\n */\nexport function handler(handlerFunction, name, dependencies, options) {\n  name = name || handlerFunction[SPECIAL_PROPS.NAME];\n  dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT];\n\n  if (!name) {\n    throw new YError('E_NO_HANDLER_NAME', handlerFunction);\n  }\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n      options,\n    },\n    async (...args) => handlerFunction.bind(null, ...args),\n  );\n}\n\n/**\n * Allows to create an initializer with a simple handler automagically\n * @param  {Function} handlerFunction\n * The handler function\n * @return {Function}\n * Returns a new initializer\n * @example\n * import Knifecycle, { autoHandler } from 'knifecycle';\n *\n * new Knifecycle()\n * .register(autoHandler(getUser));\n *\n * const QUERY = `SELECT * FROM users WHERE id=$1`\n * async function getUser({ db }, userId) {\n *   const [row] = await db.query(QUERY, userId);\n *\n *   return row;\n * }\n */\nexport function autoHandler(handlerFunction) {\n  const name = readFunctionName(handlerFunction);\n  const source = handlerFunction.toString();\n  const dependencies = parseInjections(source);\n\n  return initializer(\n    {\n      name,\n      type: 'service',\n      inject: dependencies,\n    },\n    async (...args) => handlerFunction.bind(null, ...args),\n  );\n}\n\n/* Architecture Note #1.2.1: Dependencies declaration syntax\n\nThe dependencies syntax is of the following form:\n `?serviceName>mappedName`\nThe `?` flag indicates an optional dependency.\n `>mappedName` is optional and allows to inject\n `mappedName` as `serviceName`.\nIt allows to write generic services with fixed\n dependencies and remap their name at injection time.\n*/\n\n/**\n * Explode a dependency declaration an returns its parts.\n * @param  {String}  dependencyDeclaration\n * A dependency declaration string\n * @return {Object}\n * The various parts of it\n * @example\n * parseDependencyDeclaration('pgsql>db');\n * // Returns\n * {\n *   serviceName: 'pgsql',\n *   mappedName: 'db',\n *   optional: false,\n * }\n */\nexport function parseDependencyDeclaration(dependencyDeclaration) {\n  const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);\n  const [serviceName, mappedName] = (optional\n    ? dependencyDeclaration.slice(1)\n    : dependencyDeclaration\n  ).split(DECLARATION_SEPARATOR);\n\n  return {\n    serviceName,\n    mappedName: mappedName || serviceName,\n    optional,\n  };\n}\n\n/**\n * Stringify a dependency declaration from its parts.\n * @param  {Object}  dependencyDeclarationParts\n * A dependency declaration string\n * @return {String}\n * The various parts of it\n * @example\n * stringifyDependencyDeclaration({\n *   serviceName: 'pgsql',\n *   mappedName: 'db',\n *   optional: false,\n * });\n *\n * // Returns\n * 'pgsql>db'\n */\nexport function stringifyDependencyDeclaration(dependencyDeclarationParts) {\n  return `${dependencyDeclarationParts.optional ? '?' : ''}${\n    dependencyDeclarationParts.serviceName\n  }${\n    dependencyDeclarationParts.mappedName !==\n    dependencyDeclarationParts.serviceName\n      ? '>' + dependencyDeclarationParts.mappedName\n      : ''\n  }`;\n}\n"],"file":"util.js"}