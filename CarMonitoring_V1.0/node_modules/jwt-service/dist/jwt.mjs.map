{"version":3,"sources":["../src/jwt.ts"],"names":["autoService","name","YError","ms","jwt","DEFAULT_ENV","wrappedInitializer","initJWT","ENV","JWT","time","Date","now","bind","log","noop","JWT_DURATION","readMS","duration","JWT_TOLERANCE","tolerance","jwtSecret","JWT_SECRET","secret","algorithms","length","jwtService","sign","verify","payload","algorithm","issuedAt","expiresAt","validAt","includes","token","Promise","resolve","reject","JSON","stringify","iat","Math","floor","exp","nbf","err","wrap","clockTolerance","clockTimestamp","decoded","args","value","errorCode","defaultValue","undefined","isRequired","hasValue","finalValue","computedDuration"],"mappings":"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","sourcesContent":["import { autoService, name } from 'knifecycle';\nimport YError from 'yerror';\nimport ms from 'ms';\nimport jwt from 'jsonwebtoken';\nimport type { SignOptions, Algorithm } from 'jsonwebtoken';\nimport type { LogService, TimeService } from 'common-services';\n\nconst DEFAULT_ENV: JWT_ENV = {};\n\nexport interface JWT_CONFIG {\n  secret?: string;\n  duration: string;\n  tolerance?: string;\n  algorithms: Array<string>;\n}\n\nexport interface JWT_ENV {\n  JWT_SECRET?: string;\n}\n\nexport type Payload = {\n  [key: string]: any;\n};\n\n/**\n@typedef JWTSignResult\n*/\nexport type JWTSignResult = {\n  token: string;\n  issuedAt: number;\n  expiresAt: number;\n  validAt: number;\n};\n\nexport interface JWTService<PAYLOAD extends {} = Payload> {\n  sign: (payload: PAYLOAD, algorithm?: string) => Promise<JWTSignResult>;\n  verify: (token: string) => Promise<PAYLOAD>;\n}\n\nexport type JWTServiceConfig = {\n  ENV?: JWT_ENV;\n  JWT: JWT_CONFIG;\n};\n\nexport type JWTServiceDependencies = JWTServiceConfig & {\n  time?: TimeService;\n  log?: LogService;\n};\n\nexport interface JWTServiceInitializer<PAYLOAD extends {} = Payload> {\n  (dependencies: JWTServiceDependencies): Promise<JWTService<PAYLOAD>>;\n}\n\n/* Architecture Note #1: JWT service\n\nThis JWT service is a simple wrapper around the `jsonwebtoken` NPM\n module. It add a level of abstraction simply providing a way to\n sign and verify JSON Web Tokens in my apps.\n\nIt also cast error to `YError` ones and adds a tolerance for expired\n tokens so that clock drifts between instances won't be a problem.\nIt also uses `Knifecycle` for a drop in dependency injection\n support in projetcs using Knifecycle.\n\nFinally, it deal with promises which are more convenient than the\n original API.\n*/\nconst wrappedInitializer: JWTServiceInitializer = name(\n  'jwt',\n  autoService(initJWT) as JWTServiceInitializer,\n);\n\nexport default wrappedInitializer;\n\n/**\n * Instantiate the JWT service\n * @name initJWTService\n * @function\n * @param  {Object}     services\n * The services to inject\n * @param  {Function}   services.JWT\n * The JWT service configuration object\n * @param  {Function}   [services.log]\n * A logging function\n * @param  {Function}   [services.time]\n * A function returning the current timestamp\n * @return {Promise<JWTService>}\n * A promise of the jwt service\n * @example\n * import initJWTService from 'jwt-service';\n *\n * const jwt = await initJWTService({\n *   JWT: {\n *     secret: 'secret',\n *     duration: '2d',\n *     tolerance: '2h',\n *     algorithms: ['HS256'],\n *   },\n *   log: console.log.bind(console),\n *   time: Date.now.bind(Date),\n * });\n *\n * const token = await jwt.sign({ my: 'payload' });\n */\nasync function initJWT<PAYLOAD extends {} = Payload>({\n  ENV = DEFAULT_ENV,\n  JWT,\n  time = Date.now.bind(Date),\n  log = noop,\n}: JWTServiceDependencies): Promise<JWTService<PAYLOAD>> {\n  const JWT_DURATION = readMS(JWT.duration, 'E_BAD_JWT_DURATION');\n  const JWT_TOLERANCE = readMS(JWT.tolerance, 'E_BAD_JWT_TOLERANCE', 0);\n  const jwtSecret = ENV.JWT_SECRET || JWT.secret;\n\n  if (!jwtSecret) {\n    throw new YError('E_NO_JWT_SECRET');\n  }\n  if (!(JWT.algorithms && JWT.algorithms.length)) {\n    throw new YError('E_NO_JWT_ALGORITHMS');\n  }\n\n  /**\n  @typedef JWTService\n*/\n  const jwtService: JWTService<PAYLOAD> = {\n    sign,\n    verify,\n  };\n\n  /**\n   * Sign the given payload\n   * @memberof JWTService\n   * @param  {Object}   payload      The payload to sign\n   * @param  {String}   [algorithm]  The signing algorithm\n   * @return {Promise<JWTSignResult>}\n   * A promise to be resolved with the signed token.\n   * @example\n   * const token = await jwt.sign({ my: 'payload' });\n   */\n  async function sign(\n    payload: object,\n    algorithm: string = JWT.algorithms[0],\n  ): Promise<JWTSignResult> {\n    const issuedAt = time();\n    const expiresAt = issuedAt + JWT_DURATION;\n    const validAt = issuedAt;\n\n    if (!JWT.algorithms.includes(algorithm)) {\n      throw new YError('E_UNKNOWN_ALGORYTHM', algorithm, JWT.algorithms);\n    }\n\n    const token = await new Promise<string>((resolve, reject) => {\n      jwt.sign(\n        JSON.stringify({\n          ...payload,\n          iat: Math.floor(issuedAt / 1000),\n          exp: Math.floor(expiresAt / 1000),\n          nbf: Math.floor(validAt / 1000),\n        }),\n        jwtSecret,\n        {\n          algorithm,\n        } as SignOptions,\n        (err, token: string) => {\n          if (err) {\n            reject(YError.wrap(err, 'E_JWT', payload));\n            return;\n          }\n          resolve(token);\n        },\n      );\n    });\n\n    return {\n      token,\n      issuedAt,\n      expiresAt,\n      validAt,\n    };\n  }\n\n  /**\n   * Verify and decode the given token\n   * @memberof JWTService\n   * @param  {String}   [token]  The token to decode\n   * @return {Promise<Object>}\n   * A promise to be resolved with the token payload.\n   * @example\n   * const payload = await jwt.verify('my.jwt.token');\n   */\n  async function verify(token: string): Promise<PAYLOAD> {\n    return new Promise((resolve, reject) => {\n      jwt.verify(\n        token,\n        jwtSecret,\n        {\n          algorithms: (JWT.algorithms as unknown) as Algorithm[],\n          clockTolerance: Math.floor(JWT_TOLERANCE / 1000),\n          clockTimestamp: Math.floor(time() / 1000),\n        },\n        (err, decoded) => {\n          if (err) {\n            if ('TokenExpiredError' === err.name) {\n              reject(YError.wrap(err, 'E_JWT_EXPIRED', token));\n              return;\n            }\n            if ('JsonWebTokenError' === err.name) {\n              reject(YError.wrap(err, 'E_JWT_MALFORMED', token));\n              return;\n            }\n            reject(YError.wrap(err, 'E_JWT', token));\n            return;\n          }\n          resolve(decoded as PAYLOAD);\n        },\n      );\n    });\n  }\n\n  log('info', 'JWT service initialized!');\n\n  return jwtService;\n}\n\n// eslint-disable-next-line\nfunction noop(...args: any[]): any {}\n\nfunction readMS(\n  value: string,\n  errorCode: string,\n  defaultValue: number | undefined = undefined,\n) {\n  const isRequired = 'undefined' === typeof defaultValue;\n  const hasValue = 'undefined' !== typeof value;\n  const finalValue = hasValue ? value : '' + defaultValue;\n\n  if (isRequired && !hasValue) {\n    throw new YError(errorCode, value);\n  }\n\n  try {\n    const computedDuration = ms(finalValue);\n\n    if ('undefined' === typeof computedDuration) {\n      throw new YError(errorCode, value);\n    }\n\n    return computedDuration;\n  } catch (err) {\n    throw YError.wrap(err, errorCode, finalValue);\n  }\n}\n"],"file":"jwt.mjs"}